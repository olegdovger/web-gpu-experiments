var lt=Object.defineProperty;var ht=(e,t,n)=>t in e?lt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var w=(e,t,n)=>(ht(e,typeof t!="symbol"?t+"":t,n),n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&i(c)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();const ut={r:.15,g:.15,b:.15,a:1},gt={r:0,g:0,b:0,a:1},ft={debug:!1,log:!1,debounceInterval:1e3,clearValue:ut,fontColorValue:gt,fontSource:"/fonts/JetBrainsMono-Regular.ttf"};function y(e,t){if(!e)throw new Error(t)}class pt{constructor(t,n=100,i){w(this,"resizeObserver");const s=t.parentElement,o=n<100?100:n;if(this.resizeObserver=new ResizeObserver(this.debounce(o,c=>{const a=c.find(h=>h.target===s);if(!a)return;const g=a.contentBoxSize[0].inlineSize,r=a.contentBoxSize[0].blockSize;i(g,r)})),!!s)try{this.resizeObserver.observe(s,{box:"device-pixel-content-box"})}catch{this.resizeObserver.observe(s,{box:"content-box"})}}debounce(t,n){let i;return(...s)=>{i&&clearTimeout(i),i=setTimeout(()=>n.apply(this,s),t)}}disconnect(){this.resizeObserver.disconnect()}}const dt=.001;class G{constructor(t,n){this.x=t,this.y=n}add(t){return new G(this.x+t.x,this.y+t.y)}subtract(t){return new G(this.x-t.x,this.y-t.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();return new G(this.x/t,this.y/t)}scale(t){return new G(this.x*t,this.y*t)}cross(t){return this.x*t.y-this.y*t.x}dot(t){return this.x*t.x+this.y*t.y}distance(t){return this.subtract(t).length()}lerp(t,n){return this.add(t.subtract(this).scale(n))}equalsEpsilon(t,n){return Math.abs(this.x-t.x)<n&&Math.abs(this.y-t.y)<n}equals(t){return this.equalsEpsilon(t,dt)}}function xt(e,t,n,i){const s=new Float64Array(t*n),o=new Float64Array(t*n),c=1e20;for(let f=0;f<t*n;f++){const v=e.data[f*4+3]/255;s[f]=v===1?0:v===0?c:Math.pow(Math.max(0,.5-v),2),o[f]=v===1?c:v===0?0:Math.pow(Math.max(0,v-.5),2)}const a=Math.max(t,n),g=new Float64Array(a),r=new Float64Array(a+1),h=new Uint16Array(a*2);nt(s,t,n,g,h,r),nt(o,t,n,g,h,r);const l=new Uint8ClampedArray(t*n);for(let f=0;f<t*n;f++){const U=.5-(Math.sqrt(s[f])-Math.sqrt(o[f]))/i;l[f]=U*255}const m=new Uint8ClampedArray(t*n*4);for(let f=0;f<t*n;f++)m[4*f+0]=l[f],m[4*f+1]=l[f],m[4*f+2]=l[f],m[4*f+3]=l[f];return new ImageData(m,t,n)}const X=1e20;function et(e,t,n,i,s,o,c){let a,g,r,h;for(o[0]=0,c[0]=-X,c[1]=X,a=0;a<i;a++)s[a]=e[t+a*n];for(a=1,g=0,r=0;a<i;a++){do h=o[g],r=(s[a]-s[h]+a*a-h*h)/(a-h)/2;while(r<=c[g]&&--g>-1);g++,o[g]=a,c[g]=r,c[g+1]=X}for(a=0,g=0;a<i;a++){for(;c[g+1]<a;)g++;h=o[g],e[t+a*n]=s[h]+(a-h)*(a-h)}}function nt(e,t,n,i,s,o){for(let c=0;c<t;c++)et(e,c,t,n,i,s,o);for(let c=0;c<n;c++)et(e,c*t,1,t,i,s,o)}const j=48,$=4,yt=8;async function mt(e,t,n){const i=document.createElement("canvas");i.width=e.atlas.width,i.height=e.atlas.height;const s=i.getContext("2d");y(s,"Could not get 2D context.");const o=1/e.unitsPerEm*j,c="FontForAtlas",a=new FontFace(c,t);await a.load(),document.fonts.add(a),s.font=`${j}px ${c}`;const g=[...e.glyphs.values()];for(let r=0;r<g.length;r++){const h=g[r],l=e.atlas.positions[r],m=e.atlas.sizes[r];s.fillStyle="rgba(255, 255, 255, 1)",s.fillText(String.fromCharCode(h.id),l.x-h.x*o+$,l.y+m.y+h.y*o-$)}if(n!=null&&n.useSDF){const r=s.getImageData(0,0,e.atlas.width,e.atlas.height),h=xt(r,e.atlas.width,e.atlas.height,yt);s.putImageData(h,0,0)}return await createImageBitmap(i)}function vt(e,t,n){var h;const i=[],s=[];let o=0;const c=1/e.unitsPerEm*n,a=$*n/j;for(let l=0;l<t.length;l++){const m=t[l].charCodeAt(0),f=e.glyphs.get(m);y(f,`
Glyph not found for character ${t[l]}
  character position: ${l}
  text: "${t}"`);const{y:v,width:u,height:U,lsb:P,rsb:x}=f;let p=0;t[l-1]&&t[l]&&(p=e.kern(t[l-1].charCodeAt(0),t[l].charCodeAt(0))),i.push(new G(o+(P+p)*c-a,(e.capHeight-v-U)*c-a)),s.push(new G(u*c+a*2,U*c+a*2)),o+=(P+p+u+x)*c}const g=(((h=i[i.length-1])==null?void 0:h.x)??0)+s[s.length-1].x,r=e.capHeight*n/e.unitsPerEm;return{positions:i,sizes:s,boundingRectangle:{width:Math.ceil(g),height:Math.ceil(r)}}}const wt=`struct VertexInput {
  @location(0) position: vec2f,
  @builtin(instance_index) instance: u32
};

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(1) @interpolate(flat) instance: u32,
  @location(2) @interpolate(linear) vertex: vec2f,
  @location(3) @interpolate(linear) uv: vec2f,
};

struct Glyph {
  position: vec2f,
  _unused: f32,
  fontSize: f32,
  color: vec4f,
  size: vec2f,
  uv: vec2f,
  uvSize: vec2f,
  window: vec2f,
};

struct GlyphData {
  glyphs: array<Glyph>,
};

@group(0) @binding(0) var<storage> text: GlyphData;
@group(0) @binding(1) var fontAtlasSampler: sampler;
@group(0) @binding(2) var fontAtlas: texture_2d<f32>;

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    let g = text.glyphs[input.instance];
    let vertex = mix(g.position.xy, g.position.xy + g.size, input.position);

    output.position = vec4f(vertex / g.window * 2 - 1, 0, 1);
    output.position.y = -output.position.y;
    output.vertex = vertex;
    output.uv = mix(g.uv, g.uv + g.uvSize, input.position);
    output.instance = input.instance;
    return output;
}

override devicePixelRatio: f32 = 2.0;

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
    let g = text.glyphs[input.instance];
    let distance = textureSample(fontAtlas, fontAtlasSampler, input.uv).a;

    var width = mix(0.4, 0.1, clamp(g.fontSize, 0, 40) / 40.0);
    width /= devicePixelRatio;

    let alpha = g.color.a * smoothstep(0.5 - width, 0.5 + width, distance);

    return vec4f(g.color.rgb, alpha);
}
`,K=16*1e3,bt=4;class Ut{constructor(t){w(this,"glyphData",new Float32Array(K));w(this,"glyphCount",0);w(this,"vertexBuffer");w(this,"textBuffer");w(this,"textBindGroupLayout");w(this,"textBindGroup",null);w(this,"textPipeline");w(this,"sampler");w(this,"fontLookups",null);w(this,"device");w(this,"context");w(this,"colorTextureView");w(this,"clearValue");w(this,"fontColorValue");w(this,"width");w(this,"height");const{device:n,context:i,colorTextureView:s,width:o,height:c,clearValue:a,fontColorValue:g}=t;this.device=n,this.colorTextureView=s,this.context=i,this.width=o,this.height=c,this.clearValue=a,this.fontColorValue=g;const r=n.createShaderModule({code:wt});this.vertexBuffer=n.createBuffer({label:"vertex",size:2*2*3*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.textBuffer=n.createBuffer({label:"text",size:K*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.textBindGroupLayout=n.createBindGroupLayout({label:"text bind group layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});const h=n.createPipelineLayout({label:"text pipeline layout",bindGroupLayouts:[this.textBindGroupLayout]});this.sampler=n.createSampler({addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}),this.textPipeline=n.createRenderPipeline({label:"text",layout:h,vertex:{module:r,entryPoint:"vertexMain",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:r,entryPoint:"fragmentMain",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"}}}],constants:{devicePixelRatio:window.devicePixelRatio}},multisample:{count:bt}});const l=[0,0,1,0,0,1,1,0,0,1,1,1];n.queue.writeBuffer(this.vertexBuffer,0,new Float32Array(l))}setFont(t,n){this.fontLookups=t,this.textBindGroup=this.device.createBindGroup({label:"text",layout:this.textBindGroupLayout,entries:[{binding:0,resource:{buffer:this.textBuffer}},{binding:1,resource:this.sampler},{binding:2,resource:n.createView()}]})}text(t,n,i,s){var a,g,r,h;y(this.fontLookups,"Font must be set.");const o=vt(this.fontLookups,t,i);let c=0;for(let l=0;l<o.positions.length;l++){const m=o.positions[l].add(n),f=o.sizes[l],v=this.fontLookups.uvs.get(t[l].charCodeAt(0));y(v,"UV does not exist.");const u=(s==null?void 0:s.x)??((a=this.fontColorValue)==null?void 0:a.r),U=(s==null?void 0:s.y)??((g=this.fontColorValue)==null?void 0:g.g),P=(s==null?void 0:s.z)??((r=this.fontColorValue)==null?void 0:r.b),x=(s==null?void 0:s.w)??((h=this.fontColorValue)==null?void 0:h.a),p=16;this.glyphData[this.glyphCount*p+0]=m.x,this.glyphData[this.glyphCount*p+1]=m.y,this.glyphData[this.glyphCount*p+2]=0,this.glyphData[this.glyphCount*p+3]=i,this.glyphData[this.glyphCount*p+4]=u,this.glyphData[this.glyphCount*p+5]=U,this.glyphData[this.glyphCount*p+6]=P,this.glyphData[this.glyphCount*p+7]=x,this.glyphData[this.glyphCount*p+8]=f.x,this.glyphData[this.glyphCount*p+9]=f.y,this.glyphData[this.glyphCount*p+10]=v.x,this.glyphData[this.glyphCount*p+11]=v.y,this.glyphData[this.glyphCount*p+12]=v.z,this.glyphData[this.glyphCount*p+13]=v.w,this.glyphData[this.glyphCount*p+14]=this.width/window.devicePixelRatio,this.glyphData[this.glyphCount*p+15]=this.height/window.devicePixelRatio,this.glyphCount+=1,c+=f.x}}render(){y(this.context,"Context does not exist.");const t=this.device.createCommandEncoder(),n=t.beginRenderPass({colorAttachments:[{view:this.colorTextureView,resolveTarget:this.context.getCurrentTexture().createView({label:"antialiased resolve target"}),clearValue:this.clearValue,loadOp:"clear",storeOp:"store"}]});this.device.queue.writeBuffer(this.textBuffer,0,this.glyphData),n.setViewport(0,0,this.width,this.height,0,1),n.setVertexBuffer(0,this.vertexBuffer),n.setPipeline(this.textPipeline),n.setBindGroup(0,this.textBindGroup),n.draw(6,this.glyphCount),n.end(),this.device.queue.submit([t.finish()]),this.glyphCount=0,this.glyphData=new Float32Array(K)}}async function Pt(e,t){const n={width:t.width,height:t.height},i=e.createTexture({label:"image bitmap",size:n,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return e.queue.copyExternalImageToTexture({source:t},{texture:i},n),i}class Ct{constructor(t){w(this,"data");w(this,"position",0);this.data=new Uint8Array(t)}getUint16(){const t=(this.data[this.position]<<8|this.data[this.position+1])>>>0;return this.position+=2,t}getInt16(){const t=this.getUint16();return t&32768?t-65536:t}getUint32(){return this.getInt32()>>>0}getInt32(){const t=this.data[this.position]<<24|this.data[this.position+1]<<16|this.data[this.position+2]<<8|this.data[this.position+3];return this.position+=4,t}getFixed(){const t=this.getUint16(),n=this.getUint16();return t+n/65536}getDate(){const n=(this.getUint32()*4294967296+this.getUint32())*1e3+Date.UTC(1904,1,1);return new Date(n)}getFWord(){return this.getInt16()}getString(t){const n=this.getDataSlice(this.position,t),i=new TextDecoder().decode(n);return this.position+=t,i}getDataSlice(t,n){const i=new Uint8Array(n);for(let s=0;s<n;s++)i[s]=this.data[t+s];return i}getPosition(){return this.position}setPosition(t){this.position=t}runAt(t,n){const i=this.position;this.setPosition(t);const s=n();return this.setPosition(i),s}}function Mt(e,{debug:t}){var a,g,r,h,l;let n={};const i=new Ct(e);i.getUint32();const s=i.getUint16();if(i.getUint16(),i.getUint16(),i.getUint16(),e.byteLength===0)throw new Error("File is empty.");if(s>20)throw new Error("This is not a TTF file.");const o={};for(let m=0;m<s;m++){const f=i.getString(4);if(o[f]={checksum:i.getUint32(),offset:i.getUint32(),length:i.getUint32()},f!=="head"){const v=St(i.getDataSlice(o[f].offset,4*Math.ceil(o[f].length/4)));y(v===o[f].checksum,`Checksum for table ${f} is invalid.`)}}const c="table is missing. Please use other font variant that contains it.";return y(o.head.offset,`head ${c}`),n.head=It(i,o.head.offset),y(o.cmap.offset,`cmap ${c}`),n.cmap=Tt(i,o.cmap.offset),y(o.maxp.offset,`maxp ${c}`),n.maxp=Ft(i,o.maxp.offset),y(o.hhea.offset,`hhea ${c}`),n.hhea=At(i,o.hhea.offset),y(o.hmtx.offset,`hmtx ${c}`),n.hmtx=Dt(i,o.hmtx.offset,(a=n.maxp)==null?void 0:a.numGlyphs,(g=n.hhea)==null?void 0:g.numberOfHMetrics),y(o.loca.offset,`loca ${c}`),n.loca=Gt(i,o.loca.offset,(r=n.maxp)==null?void 0:r.numGlyphs,(h=n.head)==null?void 0:h.indexToLocFormat),y(o.glyf.offset,`glyf ${c}`),n.glyf=Et(i,o.glyf.offset,n.loca,(l=n.head)==null?void 0:l.indexToLocFormat),o.GPOS&&(n.GPOS=Ot(i,o.GPOS.offset,t)),n}function St(e){const t=e.length/4;y(t===Math.floor(t),"Data length must be divisible by 4.");let n=0;for(let i=0;i<t;i++){const o=(e[i*4]<<24)+(e[i*4+1]<<16)+(e[i*4+2]<<8)+e[i*4+3]>>>0;n=(n+o&4294967295)>>>0}return n}function It(e,t){const n=e.getPosition();e.setPosition(t);const i={majorVersion:e.getUint16(),minorVersion:e.getUint16(),fontRevision:e.getFixed(),checksumAdjustment:e.getUint32(),magicNumber:e.getUint32(),flags:e.getUint16(),unitsPerEm:e.getUint16(),created:e.getDate(),modified:e.getDate(),xMin:e.getFWord(),yMin:e.getFWord(),xMax:e.getFWord(),yMax:e.getFWord(),macStyle:e.getUint16(),lowestRecPPEM:e.getUint16(),fontDirectionHint:e.getInt16(),indexToLocFormat:e.getInt16(),glyphDataFormat:e.getInt16()};return y(i.magicNumber===1594834165,"Invalid magic number."),e.setPosition(n),i}function Tt(e,t){const n=e.getPosition();e.setPosition(t);const i=e.getUint16();y(i===0,"Invalid cmap table version.");const s=e.getUint16(),o=[];let c=null;for(let d=0;d<s;d++){const C=e.getUint16(),M=e.getUint16(),S=e.getUint32();o.push({platformID:C,encodingID:M,offset:S}),(C===3&&(M===0||M===1||M===10)||C===0&&(M===0||M===1||M===2||M===3||M===4))&&(c=S)}y(c!==null,"No supported cmap table found.");const a=e.getUint16();y(a===4,`Unsupported cmap table format. Expected 4, found ${a}.`);const g=e.getUint16(),r=e.getUint16(),h=e.getUint16(),l=h/2,m=e.getUint16(),f=e.getUint16(),v=e.getUint16(),u=[];for(let d=0;d<l;d++)u.push(e.getUint16());e.getUint16();const U=[];for(let d=0;d<l;d++)U.push(e.getUint16());const P=[];for(let d=0;d<l;d++)P.push(e.getUint16());const x=e.getPosition(),p=[];for(let d=0;d<l;d++)p.push(e.getUint16());const b=new Map;for(let d=0;d<l-1;d++){let C=0;const M=u[d],S=U[d],T=P[d],F=p[d];for(let A=S;A<=M;A++){if(F!==0){const O=(A-S)*2,z=d*2,R=x+F+z+O;e.setPosition(R),C=e.getUint16(),C!==0&&(C=C+T&65535)}else C=A+T&65535;b.set(A,C)}}const I={version:i,numTables:s,encodingRecords:o,format:a,length:g,language:r,segCountX2:h,segCount:l,searchRange:m,entrySelector:f,rangeShift:v,endCodes:u,startCodes:U,idDeltas:P,idRangeOffsets:p,glyphIndexMap:b};return e.setPosition(n),I}function Ft(e,t){const n=e.getPosition();e.setPosition(t);const i=e.getUint32(),s=i===20480?"0.5":i===65536?"1.0":null;y(s,`Unsupported maxp table version (expected 0x00005000 or 0x00010000 but found ${i.toString(16)}).`);const o=e.getUint16(),c={version:s,numGlyphs:o};return e.setPosition(n),c}function At(e,t){const n=e.getPosition();e.setPosition(t);const i=e.getUint16(),s=e.getUint16(),o=e.getInt16(),c=e.getInt16(),a=e.getInt16(),g=e.getUint16(),r=e.getInt16(),h=e.getInt16(),l=e.getInt16(),m=e.getInt16(),f=e.getInt16(),v=e.getInt16(),u=e.getInt16(),U=e.getInt16(),P=e.getInt16(),x=e.getInt16(),p=e.getInt16(),b=e.getUint16(),I={majorVersion:i,minorVersion:s,ascender:o,descender:c,lineGap:a,advanceWidthMax:g,minLeftSideBearing:r,minRightSideBearing:h,xMaxExtent:l,caretSlopeRise:m,caretSlopeRun:f,caretOffset:v,reserved1:u,reserved2:U,reserved3:P,reserved4:x,metricDataFormat:p,numberOfHMetrics:b};return e.setPosition(n),I}function Dt(e,t,n,i){const s=e.getPosition();e.setPosition(t);const o=[];for(let g=0;g<i;g++)o.push({advanceWidth:e.getUint16(),leftSideBearing:e.getInt16()});const c=[];for(let g=0;g<n-i;g++)c.push(e.getInt16());const a={hMetrics:o,leftSideBearings:c};return y(o.length+c.length===n,`The number of hMetrics (${o.length}) plus the number of left side bearings (${c.length}) must equal the number of glyphs (${n}).`),e.setPosition(s),a}function Gt(e,t,n,i){const s=e.getPosition();e.setPosition(t);const o=[];for(let c=0;c<n+1;c++)o.push(i===0?e.getUint16():e.getUint32());return e.setPosition(s),{offsets:o}}function Et(e,t,n,i){const s=e.getPosition();e.setPosition(t);const o=[];for(let c=0;c<n.offsets.length-1;c++){const a=i===0?2:1,g=n.offsets[c]*a;e.setPosition(t+g),o.push({numberOfContours:e.getInt16(),xMin:e.getInt16(),yMin:e.getInt16(),xMax:e.getInt16(),yMax:e.getInt16()})}return e.setPosition(s),o}function Ot(e,t,n){const i=e.getPosition();e.setPosition(t);const s=e.getUint16(),o=e.getUint16();y(s===1&&o===0,"Only GPOS version 1.0 is supported."),e.getUint16();const c=e.getUint16(),a=e.getUint16();e.setPosition(t+c);const g=e.getUint16(),r=[],h=[];for(let u=0;u<g;u++){const U=e.getString(4),P=e.getUint16(),x={tag:U,offset:P};r.push(x)}for(let u=0;u<g;u++){e.setPosition(t+c+r[u].offset);const U=e.getUint16(),P=e.getUint16(),x=[];for(let p=0;p<P;p++)x.push(e.getUint16());h.push({tag:r[u].tag,paramsOffset:U,lookupListIndices:x})}e.setPosition(t+a);const l=e.getUint16();let m;(u=>{u[u.SingleAdjustment=1]="SingleAdjustment",u[u.PairAdjustment=2]="PairAdjustment",u[u.CursiveAttachment=3]="CursiveAttachment",u[u.MarkToBaseAttachment=4]="MarkToBaseAttachment",u[u.MarkToLigatureAttachment=5]="MarkToLigatureAttachment",u[u.MarkToMarkAttachment=6]="MarkToMarkAttachment",u[u.ContextPositioning=7]="ContextPositioning",u[u.ChainedContextPositioning=8]="ChainedContextPositioning",u[u.ExtensionPositioning=9]="ExtensionPositioning"})(m||(m={}));const f=[];for(let u=0;u<l;u++)f.push(e.getUint16());const v=[];for(let u=0;u<l;u++){e.setPosition(t+a+f[u]);const U=e.getUint16(),P=e.getUint16(),x=e.getUint16(),p=[];for(let d=0;d<x;d++)p.push(e.getUint16());let b;P&16&&(b=e.getUint16());const I={lookupType:U,lookupFlag:P,subtables:[],markFilteringSet:b};if(U===9)for(let d=0;d<x;d++){e.setPosition(t+a+f[u]+p[d]);const C=e.getUint16(),M=e.getUint16(),S=e.getUint32();let T={};e.runAt(t+a+f[u]+p[d]+S,()=>{if(M===2){const F=e.getUint16();if(y(F===1||F===2,"Invalid posFormat."),T.posFormat=F,F===1){const A=e.getUint16(),O=e.getUint16(),z=e.getUint16(),R=e.getUint16(),W=[];for(let D=0;D<R;D++)W.push(e.getUint16());const k=[];for(let D=0;D<R;D++){e.setPosition(t+a+f[u]+p[d]+S+W[D]);const H=e.getUint16(),q=[];for(let V=0;V<H;V++){const E={secondGlyph:e.getUint16()},N=_(e,O),L=_(e,z);N&&(E.value1=N),L&&(E.value2=L),q.push(E)}k.push(q)}T.coverage=e.runAt(t+a+f[u]+p[d]+S+A,()=>{const D=e.getUint16();return it(e,D)}),T={...T,valueFormat1:O,valueFormat2:z,pairSets:k}}else if(F===2){const A=e.getUint16(),O=e.getUint16(),z=e.getUint16(),R=e.getUint16(),W=e.getUint16(),k=e.getUint16(),D=e.getUint16();T.coverage=e.runAt(t+a+f[u]+p[d]+S+A,()=>{const E=e.getUint16();return it(e,E)});let H=e.runAt(t+a+f[u]+p[d]+S+R,()=>st(e)),q=e.runAt(t+a+f[u]+p[d]+S+W,()=>st(e));const V=[];for(let E=0;E<k;E++){let N=[];for(let L=0;L<D;L++){const Y={},Q=_(e,O),tt=_(e,z);Q&&(Y.value1=Q),tt&&(Y.value2=tt),N.push(Y)}V.push(N)}T={...T,valueFormat1:O,valueFormat2:z,classDef1:H,classDef2:q,classRecords:V}}else n&&console.warn("Only Pair Adjustment lookup format 1 and 2 are supported.")}}),I.subtables.push({posFormat:C,extensionLookupType:M,extension:T})}else n&&console.warn("Only Extension Positioning lookup type is supported.");v.push(I)}return e.setPosition(i),{features:h,lookups:v}}function _(e,t){let n={};if(t&1&&(n.xPlacement=e.getInt16()),t&2&&(n.yPlacement=e.getInt16()),t&4&&(n.xAdvance=e.getInt16()),t&8&&(n.yAdvance=e.getInt16()),t&16&&(n.xPlaDevice=e.getInt16()),t&32&&(n.yPlaDevice=e.getInt16()),t&64&&(n.xAdvDevice=e.getInt16()),t&128&&(n.yAdvDevice=e.getInt16()),Object.keys(n).length!==0)return n}function it(e,t){if(t===2){const n=e.getUint16(),i=[];for(let s=0;s<n;s++)i.push({startGlyphID:e.getUint16(),endGlyphID:e.getUint16(),startCoverageIndex:e.getUint16()});return{coverageFormat:t,rangeRecords:i}}else throw new Error("Only Coverage Table format 2 is supported as of now.")}function st(e){const t=e.getUint16();if(t===1){const n=e.getUint16(),i=e.getUint16(),s=[];for(let o=0;o<i;o++)s.push(e.getUint16());return{format:t,startGlyph:n,classes:s}}else if(t===2){const n=e.getUint16(),i=[];for(let s=0;s<n;s++)i.push({startGlyphID:e.getUint16(),endGlyphID:e.getUint16(),class:e.getUint16()});return{format:t,ranges:i}}else throw new Error(`Unsupported ClassDef format ${t}.`)}const zt=.001;class B{constructor(t,n,i,s){this.x=t,this.y=n,this.z=i,this.w=s}add(t){return new B(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)}subtract(t){return new B(this.x-t.x,this.y-t.y,this.z-t.z,this.w-t.w)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}normalize(){const t=this.length();return new B(this.x/t,this.y/t,this.z/t,this.w/t)}scale(t){return new B(this.x*t,this.y*t,this.z*t,this.w*t)}cross(t){return new B(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x,0)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}distance(t){return this.subtract(t).length()}lerp(t,n){return this.add(t.subtract(this).scale(n))}equalsEpsilon(t,n){return Math.abs(this.x-t.x)<n&&Math.abs(this.y-t.y)<n&&Math.abs(this.z-t.z)<n&&Math.abs(this.w-t.w)<n}equals(t){return this.equalsEpsilon(t,zt)}}function Bt(e){let t=0,n=0;const i=e.map((r,h)=>({id:h,x:0,y:0,width:r.x,height:r.y}));for(const r of i)t+=r.width*r.height,n=Math.max(n,r.width);i.sort((r,h)=>h.height-r.height);const o=[{x:0,y:0,width:Math.max(Math.ceil(Math.sqrt(t/.95)),n),height:1/0}];let c=0,a=0;for(const r of i)for(let h=o.length-1;h>=0;h--){const l=o[h];if(!(r.width>l.width||r.height>l.height)){if(r.x=l.x,r.y=l.y,a=Math.max(a,r.y+r.height),c=Math.max(c,r.x+r.width),r.width===l.width&&r.height===l.height){const m=o.pop();y(m,"Regions array should not be empty."),h<o.length&&(o[h]=m)}else r.height===l.height?(l.x+=r.width,l.width-=r.width):r.width===l.width?(l.y+=r.height,l.height-=r.height):(o.push({x:l.x+r.width,y:l.y,width:l.width-r.width,height:r.height}),l.y+=r.height,l.height-=r.height);break}}const g=Math.max(ot(c),ot(a));return i.sort((r,h)=>r.id-h.id),{width:g,height:g,positions:i.map(r=>new G(r.x,r.y))}}function ot(e){let t=e;return t-=1,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,t+=1,t}function Rt(e,t){return(t?t.split("").map(i=>i.charCodeAt(0)):[...e.cmap.glyphIndexMap.keys()]).map(i=>{y(e,"TTF is missing.");const s=e.cmap.glyphIndexMap.get(i);y(s,`Couldn't find index for character '${String.fromCharCode(i)}' in glyphIndexMap.`),y(s<e.glyf.length,"Index is out of bounds for glyf table.");const o=e.hmtx.hMetrics.at(-1);y(o,"The last advance is missing, which means that hmtx table is probably empty.");const c=s<e.hhea.numberOfHMetrics?e.hmtx.hMetrics[s]:{leftSideBearing:e.hmtx.leftSideBearings[s-e.hhea.numberOfHMetrics],advanceWidth:o.advanceWidth},a=e.glyf[s];return{id:i,character:String.fromCharCode(i),x:a.xMin,y:a.yMin,width:a.xMax-a.xMin,height:a.yMax-a.yMin,lsb:c.leftSideBearing,rsb:c.advanceWidth-c.leftSideBearing-(a.xMax-a.xMin)}})}function Vt(e,t){var U,P;const n=1/e.head.unitsPerEm*j,i=Rt(e,t==null?void 0:t.alphabet),s=x=>Math.ceil(x*n),o=i.map(x=>new G(s(x.width)+$*2,s(x.height)+$*2)),c=Bt(o);y(c.positions.length===i.length,"Packing produced different number of positions than expected.");const a={width:c.width,height:c.height,positions:c.positions,sizes:o},g=[];for(let x=0;x<i.length;x++){const p=a.positions[x],b=a.sizes[x];g.push(new B(p.x/a.width,p.y/a.height,b.x/a.width,b.y/a.height))}const r=new Map;for(const x of i)r.set(x.id,x);const h=new Map;for(let x=0;x<i.length;x++)h.set(i[x].id,g[x]);const l=new Map;let m=new Map,f=new Map,v=[];const u=(U=e.GPOS)==null?void 0:U.features.find(x=>x.tag==="kern");if(u){const x=u.lookupListIndices.map(p=>{var b;return(b=e.GPOS)==null?void 0:b.lookups[p]});for(const p of x)if(p&&(p.lookupType===2||p.lookupType===9)){for(const b of p.subtables)if(p.lookupType===9&&b.extensionLookupType===2){const I=b.extension.coverage;if(b.extension.posFormat===1){const d=b.extension.pairSets;if(I.coverageFormat===2){let C=0;for(const M of I.rangeRecords)for(let S=M.startGlyphID;S<=M.endGlyphID;S++){const T=d[C],F=l.get(S)||new Map;for(const A of T)(P=A.value1)!=null&&P.xAdvance&&F.set(A.secondGlyph,A.value1.xAdvance);F.size>0&&l.set(S,F),C++}}else console.warn(`Coverage format ${I.coverageFormat} is not supported.`)}else if(b.extension.posFormat===2)if(I.coverageFormat===2){const{classDef1:d,classDef2:C}=b.extension;m=at(d),f=at(C),v=b.extension.classRecords}else console.warn(`Coverage format ${I.coverageFormat} is not supported.`)}}}return{atlas:a,unitsPerEm:e.head.unitsPerEm,capHeight:e.hhea.ascender+e.hhea.descender,ascender:e.hhea.ascender,glyphs:r,uvs:h,kern:(x,p)=>{var S;if(!e.GPOS)return 0;const b=e.cmap.glyphIndexMap.get(x),I=e.cmap.glyphIndexMap.get(p);y(b,`Glyph not found for: "${x}"`),y(I,`Glyph not found for: "${p}"`);const d=l.get(b);if(d&&d.get(I))return d.get(I)??0;const C=m.get(b),M=f.get(I);return C&&M?((S=v[C][M].value1)==null?void 0:S.xAdvance)??0:0},ttf:e}}function at(e){const t=new Map;if(e.format===1){let n=e.startGlyph;for(const i of e.classes)t.set(n,i),n++}else if(e.format===2)for(const n of e.ranges)for(let i=n.startGlyphID;i<=n.endGlyphID;i++)t.set(i,n.class);return t}const Nt=4;let Z,ct,rt,J;async function Lt(e,t){const{fontSource:n,device:i,canvas:s,context:o}=e,{debug:c}=t,g=i.createTexture({label:"colorTexture",size:{width:s.width,height:s.height},sampleCount:Nt,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}).createView({label:"color"}),r=new Ut({device:i,context:o,colorTextureView:g,width:s.width,height:s.height,clearValue:t.clearValue,fontColorValue:t.fontColorValue});y(n,"'fontSource' must be set."),Z||(Z=await fetch(n).then(l=>l.arrayBuffer())),ct||(ct=Mt(Z,{debug:c})),J||(J=Vt(ct)),rt||(rt=await mt(J,Z,{useSDF:!0}));const h=await Pt(i,rt);return r.setFont(J,h),r}class $t{constructor(t,n){w(this,"device");w(this,"context");w(this,"canvas");w(this,"settings");this.canvas=t,this.settings=n,this.debug("initialized")}log(...t){var n;(n=this.settings)!=null&&n.log&&console.log("WebGPUEngine:",...t)}debug(...t){var n;(n=this.settings)!=null&&n.debug&&console.debug("WebGPUEngine:",...t)}error(...t){console.error("WebGPUEngine:",...t)}async initialize(t){try{const n=await navigator.gpu.requestAdapter({powerPreference:"low-power"});if(!n){this.error("WebGPU adapter is not available.");return}const i=await n.requestDevice({requiredLimits:{maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize}});this.device=i,i.lost.then(async o=>{this.error(`WebGPU device was lost: ${o.message}`),o.reason!=="destroyed"&&(await this.initialize(t),this.log("WebGPU device was re-initialized."))});const s=t.getContext("webgpu");if(!s)return;if(this.context=s,!s){this.error("WebGPU context is not available.");return}s.configure({device:i,format:navigator.gpu.getPreferredCanvasFormat()})}catch(n){this.error("Error initializing WebGPU: ",n)}}observeSizeChanges(t,n){var i;new pt(t,(i=this.settings)==null?void 0:i.debounceInterval,async(s,o)=>{t.width=s*window.devicePixelRatio,t.height=o*window.devicePixelRatio,this.debug("New width:",s,", new height:",o),await(n==null?void 0:n(s,o)),t.style.width=`${s}px`,t.style.height=`${o}px`})}render(t){this.observeSizeChanges(this.canvas,async(n,i)=>{var o;this.log("Observing canvas size changes"),await this.initialize(this.canvas);const s=await this.loadFont({fontSource:(o=this.settings)==null?void 0:o.fontSource,device:this.device,canvas:this.canvas,context:this.context},{debug:this.settings.debug??!1,clearValue:this.settings.clearValue,fontColorValue:this.settings.fontColorValue,width:n,height:i});y(t,"No post-render function provided"),t({device:this.device,context:this.context,font:s,width:n,height:i})})}loadFont(t,n){return Lt({...t},{...n})}}class kt{constructor(t,n){w(this,"engine");w(this,"settings");const i=document.createElement("canvas");if(!t)throw new Error("No element provided");t.appendChild(i),t.style.overflow="hidden",t.style.width="100%",t.style.height="100%",this.settings=n??ft,this.log("initialize"),this.engine=new $t(i,this.settings)}log(...t){var n;(n=this.settings)!=null&&n.log&&console.log("Chart:",...t)}error(...t){console.error("Chart:",...t)}async render(t){if(!t){this.error("No render function provided");return}this.engine.render(async({device:n,context:i,width:s,height:o,font:c})=>{t({device:n,context:i,width:s,height:o,font:c})})}}export{kt as C,G as V,B as a,ut as b,ft as c};
