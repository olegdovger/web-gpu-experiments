var lt=Object.defineProperty;var ht=(e,t,n)=>t in e?lt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var v=(e,t,n)=>(ht(e,typeof t!="symbol"?t+"":t,n),n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&s(c)}).observe(document,{childList:!0,subtree:!0});function n(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(i){if(i.ep)return;i.ep=!0;const o=n(i);fetch(i.href,o)}})();const ut={r:.15,g:.15,b:.15,a:1},gt={r:0,g:0,b:0,a:1},ft={debug:!1,log:!1,debounceInterval:1e3,clearValue:ut,fontColorValue:gt,fontSource:"/fonts/JetBrainsMono-Regular.ttf"};function y(e,t){if(!e)throw new Error(t)}class pt{constructor(t,n=100,s){v(this,"resizeObserver");const i=t.parentElement,o=n<100?100:n;if(this.resizeObserver=new ResizeObserver(this.debounce(o,c=>{const a=c.find(h=>h.target===i);if(!a)return;const p=a.contentBoxSize[0].inlineSize,r=a.contentBoxSize[0].blockSize;s(p,r)})),!!i)try{this.resizeObserver.observe(i,{box:"device-pixel-content-box"})}catch{this.resizeObserver.observe(i,{box:"content-box"})}}debounce(t,n){let s;return(...i)=>{s&&clearTimeout(s),s=setTimeout(()=>n.apply(this,i),t)}}disconnect(){this.resizeObserver.disconnect()}}const dt=.001;class G{constructor(t,n){this.x=t,this.y=n}add(t){return new G(this.x+t.x,this.y+t.y)}subtract(t){return new G(this.x-t.x,this.y-t.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}normalize(){const t=this.length();return new G(this.x/t,this.y/t)}scale(t){return new G(this.x*t,this.y*t)}cross(t){return this.x*t.y-this.y*t.x}dot(t){return this.x*t.x+this.y*t.y}distance(t){return this.subtract(t).length()}lerp(t,n){return this.add(t.subtract(this).scale(n))}equalsEpsilon(t,n){return Math.abs(this.x-t.x)<n&&Math.abs(this.y-t.y)<n}equals(t){return this.equalsEpsilon(t,dt)}}function xt(e,t,n,s){const i=new Float64Array(t*n),o=new Float64Array(t*n),c=1e20;for(let u=0;u<t*n;u++){const b=e.data[u*4+3]/255;i[u]=b===1?0:b===0?c:Math.pow(Math.max(0,.5-b),2),o[u]=b===1?c:b===0?0:Math.pow(Math.max(0,b-.5),2)}const a=Math.max(t,n),p=new Float64Array(a),r=new Float64Array(a+1),h=new Uint16Array(a*2);nt(i,t,n,p,h,r),nt(o,t,n,p,h,r);const l=new Uint8ClampedArray(t*n);for(let u=0;u<t*n;u++){const U=.5-(Math.sqrt(i[u])-Math.sqrt(o[u]))/s;l[u]=U*255}const m=new Uint8ClampedArray(t*n*4);for(let u=0;u<t*n;u++)m[4*u+0]=l[u],m[4*u+1]=l[u],m[4*u+2]=l[u],m[4*u+3]=l[u];return new ImageData(m,t,n)}const X=1e20;function et(e,t,n,s,i,o,c){let a,p,r,h;for(o[0]=0,c[0]=-X,c[1]=X,a=0;a<s;a++)i[a]=e[t+a*n];for(a=1,p=0,r=0;a<s;a++){do h=o[p],r=(i[a]-i[h]+a*a-h*h)/(a-h)/2;while(r<=c[p]&&--p>-1);p++,o[p]=a,c[p]=r,c[p+1]=X}for(a=0,p=0;a<s;a++){for(;c[p+1]<a;)p++;h=o[p],e[t+a*n]=i[h]+(a-h)*(a-h)}}function nt(e,t,n,s,i,o){for(let c=0;c<t;c++)et(e,c,t,n,s,i,o);for(let c=0;c<n;c++)et(e,c*t,1,t,s,i,o)}const j=48,$=4,yt=8;async function mt(e,t,n){const s=document.createElement("canvas");s.width=e.atlas.width,s.height=e.atlas.height;const i=s.getContext("2d");y(i,"Could not get 2D context.");const o=1/e.unitsPerEm*j,c="FontForAtlas",a=new FontFace(c,t);await a.load(),document.fonts.add(a),i.font=`${j}px ${c}`;const p=[...e.glyphs.values()];for(let r=0;r<p.length;r++){const h=p[r],l=e.atlas.positions[r],m=e.atlas.sizes[r];i.fillStyle="rgba(255, 255, 255, 1)",i.fillText(String.fromCharCode(h.id),l.x-h.x*o+$,l.y+m.y+h.y*o-$)}if(n!=null&&n.useSDF){const r=i.getImageData(0,0,e.atlas.width,e.atlas.height),h=xt(r,e.atlas.width,e.atlas.height,yt);i.putImageData(h,0,0)}return await createImageBitmap(s)}function vt(e,t,n){var h;const s=[],i=[];let o=0;const c=1/e.unitsPerEm*n,a=$*n/j;for(let l=0;l<t.length;l++){const m=t[l].charCodeAt(0),u=e.glyphs.get(m);y(u,`
Glyph not found for character ${t[l]}
  character position: ${l}
  text: "${t}"`);const{y:b,width:g,height:U,lsb:P,rsb:f}=u;let x=0;t[l-1]&&t[l]&&(x=e.kern(t[l-1].charCodeAt(0),t[l].charCodeAt(0))),s.push(new G(o+(P+x)*c-a,(e.capHeight-b-U)*c-a)),i.push(new G(g*c+a*2,U*c+a*2)),o+=(P+x+g+f)*c}const p=(((h=s[s.length-1])==null?void 0:h.x)??0)+i[i.length-1].x,r=e.capHeight*n/e.unitsPerEm;return{positions:s,sizes:i,boundingRectangle:{width:Math.ceil(p),height:Math.ceil(r)}}}const wt=`struct VertexInput {
  @location(0) position: vec2f,
  @builtin(instance_index) instance: u32
};

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(1) @interpolate(flat) instance: u32,
  @location(2) @interpolate(linear) vertex: vec2f,
  @location(3) @interpolate(linear) uv: vec2f,
};

struct Glyph {
  position: vec2f,
  _unused: f32,
  fontSize: f32,
  color: vec4f,
  size: vec2f,
  uv: vec2f,
  uvSize: vec2f,
  window: vec2f,
};

struct GlyphData {
  glyphs: array<Glyph>,
};

@group(0) @binding(0) var<storage> text: GlyphData;
@group(0) @binding(1) var fontAtlasSampler: sampler;
@group(0) @binding(2) var fontAtlas: texture_2d<f32>;

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
    var output: VertexOutput;
    let g = text.glyphs[input.instance];
    let vertex = mix(g.position.xy, g.position.xy + g.size, input.position);

    output.position = vec4f(vertex / g.window * 2 - 1, 0, 1);
    output.position.y = -output.position.y;
    output.vertex = vertex;
    output.uv = mix(g.uv, g.uv + g.uvSize, input.position);
    output.instance = input.instance;
    return output;
}

override devicePixelRatio: f32 = 2.0;

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
    let g = text.glyphs[input.instance];
    let distance = textureSample(fontAtlas, fontAtlasSampler, input.uv).a;

    var width = mix(0.4, 0.1, clamp(g.fontSize, 0, 40) / 40.0);
    width /= devicePixelRatio;

    let alpha = g.color.a * smoothstep(0.5 - width, 0.5 + width, distance);

    return vec4f(g.color.rgb, alpha);
}
`,K=16*1e3,bt=4;class Ut{constructor(t){v(this,"glyphData",new Float32Array(K));v(this,"glyphCount",0);v(this,"vertexBuffer");v(this,"textBuffer");v(this,"textBindGroupLayout");v(this,"textBindGroup",null);v(this,"textPipeline");v(this,"sampler");v(this,"fontLookups",null);v(this,"device");v(this,"context");v(this,"colorTextureView");v(this,"clearValue");v(this,"fontColorValue");v(this,"width");v(this,"height");const{device:n,context:s,colorTextureView:i,width:o,height:c,clearValue:a,fontColorValue:p}=t;this.device=n,this.colorTextureView=i,this.context=s,this.width=o,this.height=c,this.clearValue=a,this.fontColorValue=p;const r=n.createShaderModule({code:wt});this.vertexBuffer=n.createBuffer({label:"vertex",size:2*2*3*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST}),this.textBuffer=n.createBuffer({label:"text",size:K*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),this.textBindGroupLayout=n.createBindGroupLayout({label:"text bind group layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}}]});const h=n.createPipelineLayout({label:"text pipeline layout",bindGroupLayouts:[this.textBindGroupLayout]});this.sampler=n.createSampler({addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}),this.textPipeline=n.createRenderPipeline({label:"text",layout:h,vertex:{module:r,entryPoint:"vertexMain",buffers:[{arrayStride:2*Float32Array.BYTES_PER_ELEMENT,attributes:[{shaderLocation:0,offset:0,format:"float32x2"}]}]},fragment:{module:r,entryPoint:"fragmentMain",targets:[{format:navigator.gpu.getPreferredCanvasFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"}}}],constants:{devicePixelRatio:window.devicePixelRatio}},multisample:{count:bt}});const l=[0,0,1,0,0,1,1,0,0,1,1,1];n.queue.writeBuffer(this.vertexBuffer,0,new Float32Array(l))}setFont(t,n){this.fontLookups=t,this.textBindGroup=this.device.createBindGroup({label:"text",layout:this.textBindGroupLayout,entries:[{binding:0,resource:{buffer:this.textBuffer}},{binding:1,resource:this.sampler},{binding:2,resource:n.createView()}]})}text(t,n,s,i){var c,a,p,r;y(this.fontLookups,"Font must be set.");const o=vt(this.fontLookups,t,s);for(let h=0;h<o.positions.length;h++){const l=o.positions[h].add(n),m=o.sizes[h],u=this.fontLookups.uvs.get(t[h].charCodeAt(0));y(u,"UV does not exist.");const b=(i==null?void 0:i.x)??((c=this.fontColorValue)==null?void 0:c.r),g=(i==null?void 0:i.y)??((a=this.fontColorValue)==null?void 0:a.g),U=(i==null?void 0:i.z)??((p=this.fontColorValue)==null?void 0:p.b),P=(i==null?void 0:i.w)??((r=this.fontColorValue)==null?void 0:r.a),f=16;this.glyphData[this.glyphCount*f+0]=l.x,this.glyphData[this.glyphCount*f+1]=l.y,this.glyphData[this.glyphCount*f+2]=0,this.glyphData[this.glyphCount*f+3]=s,this.glyphData[this.glyphCount*f+4]=b,this.glyphData[this.glyphCount*f+5]=g,this.glyphData[this.glyphCount*f+6]=U,this.glyphData[this.glyphCount*f+7]=P,this.glyphData[this.glyphCount*f+8]=m.x,this.glyphData[this.glyphCount*f+9]=m.y,this.glyphData[this.glyphCount*f+10]=u.x,this.glyphData[this.glyphCount*f+11]=u.y,this.glyphData[this.glyphCount*f+12]=u.z,this.glyphData[this.glyphCount*f+13]=u.w,this.glyphData[this.glyphCount*f+14]=this.width/window.devicePixelRatio,this.glyphData[this.glyphCount*f+15]=this.height/window.devicePixelRatio,this.glyphCount+=1}}render(){y(this.context,"Context does not exist.");const t=this.device.createCommandEncoder(),n=t.beginRenderPass({colorAttachments:[{view:this.colorTextureView,resolveTarget:this.context.getCurrentTexture().createView({label:"antialiased resolve target"}),clearValue:this.clearValue,loadOp:"clear",storeOp:"store"}]});this.device.queue.writeBuffer(this.textBuffer,0,this.glyphData),n.setViewport(0,0,this.width,this.height,0,1),n.setVertexBuffer(0,this.vertexBuffer),n.setPipeline(this.textPipeline),n.setBindGroup(0,this.textBindGroup),n.draw(6,this.glyphCount),n.end(),this.device.queue.submit([t.finish()]),this.glyphCount=0,this.glyphData=new Float32Array(K)}}async function Pt(e,t){const n={width:t.width,height:t.height},s=e.createTexture({label:"image bitmap",size:n,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return e.queue.copyExternalImageToTexture({source:t},{texture:s},n),s}class Ct{constructor(t){v(this,"data");v(this,"position",0);this.data=new Uint8Array(t)}getUint16(){const t=(this.data[this.position]<<8|this.data[this.position+1])>>>0;return this.position+=2,t}getInt16(){const t=this.getUint16();return t&32768?t-65536:t}getUint32(){return this.getInt32()>>>0}getInt32(){const t=this.data[this.position]<<24|this.data[this.position+1]<<16|this.data[this.position+2]<<8|this.data[this.position+3];return this.position+=4,t}getFixed(){const t=this.getUint16(),n=this.getUint16();return t+n/65536}getDate(){const n=(this.getUint32()*4294967296+this.getUint32())*1e3+Date.UTC(1904,1,1);return new Date(n)}getFWord(){return this.getInt16()}getString(t){const n=this.getDataSlice(this.position,t),s=new TextDecoder().decode(n);return this.position+=t,s}getDataSlice(t,n){const s=new Uint8Array(n);for(let i=0;i<n;i++)s[i]=this.data[t+i];return s}getPosition(){return this.position}setPosition(t){this.position=t}runAt(t,n){const s=this.position;this.setPosition(t);const i=n();return this.setPosition(s),i}}function Mt(e,{debug:t}){var a,p,r,h,l;let n={};const s=new Ct(e);s.getUint32();const i=s.getUint16();if(s.getUint16(),s.getUint16(),s.getUint16(),e.byteLength===0)throw new Error("File is empty.");if(i>20)throw new Error("This is not a TTF file.");const o={};for(let m=0;m<i;m++){const u=s.getString(4);if(o[u]={checksum:s.getUint32(),offset:s.getUint32(),length:s.getUint32()},u!=="head"){const b=St(s.getDataSlice(o[u].offset,4*Math.ceil(o[u].length/4)));y(b===o[u].checksum,`Checksum for table ${u} is invalid.`)}}const c="table is missing. Please use other font variant that contains it.";return y(o.head.offset,`head ${c}`),n.head=It(s,o.head.offset),y(o.cmap.offset,`cmap ${c}`),n.cmap=Tt(s,o.cmap.offset),y(o.maxp.offset,`maxp ${c}`),n.maxp=Ft(s,o.maxp.offset),y(o.hhea.offset,`hhea ${c}`),n.hhea=At(s,o.hhea.offset),y(o.hmtx.offset,`hmtx ${c}`),n.hmtx=Dt(s,o.hmtx.offset,(a=n.maxp)==null?void 0:a.numGlyphs,(p=n.hhea)==null?void 0:p.numberOfHMetrics),y(o.loca.offset,`loca ${c}`),n.loca=Gt(s,o.loca.offset,(r=n.maxp)==null?void 0:r.numGlyphs,(h=n.head)==null?void 0:h.indexToLocFormat),y(o.glyf.offset,`glyf ${c}`),n.glyf=Et(s,o.glyf.offset,n.loca,(l=n.head)==null?void 0:l.indexToLocFormat),o.GPOS&&(n.GPOS=Ot(s,o.GPOS.offset,t)),n}function St(e){const t=e.length/4;y(t===Math.floor(t),"Data length must be divisible by 4.");let n=0;for(let s=0;s<t;s++){const o=(e[s*4]<<24)+(e[s*4+1]<<16)+(e[s*4+2]<<8)+e[s*4+3]>>>0;n=(n+o&4294967295)>>>0}return n}function It(e,t){const n=e.getPosition();e.setPosition(t);const s={majorVersion:e.getUint16(),minorVersion:e.getUint16(),fontRevision:e.getFixed(),checksumAdjustment:e.getUint32(),magicNumber:e.getUint32(),flags:e.getUint16(),unitsPerEm:e.getUint16(),created:e.getDate(),modified:e.getDate(),xMin:e.getFWord(),yMin:e.getFWord(),xMax:e.getFWord(),yMax:e.getFWord(),macStyle:e.getUint16(),lowestRecPPEM:e.getUint16(),fontDirectionHint:e.getInt16(),indexToLocFormat:e.getInt16(),glyphDataFormat:e.getInt16()};return y(s.magicNumber===1594834165,"Invalid magic number."),e.setPosition(n),s}function Tt(e,t){const n=e.getPosition();e.setPosition(t);const s=e.getUint16();y(s===0,"Invalid cmap table version.");const i=e.getUint16(),o=[];let c=null;for(let d=0;d<i;d++){const C=e.getUint16(),M=e.getUint16(),S=e.getUint32();o.push({platformID:C,encodingID:M,offset:S}),(C===3&&(M===0||M===1||M===10)||C===0&&(M===0||M===1||M===2||M===3||M===4))&&(c=S)}y(c!==null,"No supported cmap table found.");const a=e.getUint16();y(a===4,`Unsupported cmap table format. Expected 4, found ${a}.`);const p=e.getUint16(),r=e.getUint16(),h=e.getUint16(),l=h/2,m=e.getUint16(),u=e.getUint16(),b=e.getUint16(),g=[];for(let d=0;d<l;d++)g.push(e.getUint16());e.getUint16();const U=[];for(let d=0;d<l;d++)U.push(e.getUint16());const P=[];for(let d=0;d<l;d++)P.push(e.getUint16());const f=e.getPosition(),x=[];for(let d=0;d<l;d++)x.push(e.getUint16());const w=new Map;for(let d=0;d<l-1;d++){let C=0;const M=g[d],S=U[d],T=P[d],F=x[d];for(let A=S;A<=M;A++){if(F!==0){const O=(A-S)*2,z=d*2,R=f+F+z+O;e.setPosition(R),C=e.getUint16(),C!==0&&(C=C+T&65535)}else C=A+T&65535;w.set(A,C)}}const I={version:s,numTables:i,encodingRecords:o,format:a,length:p,language:r,segCountX2:h,segCount:l,searchRange:m,entrySelector:u,rangeShift:b,endCodes:g,startCodes:U,idDeltas:P,idRangeOffsets:x,glyphIndexMap:w};return e.setPosition(n),I}function Ft(e,t){const n=e.getPosition();e.setPosition(t);const s=e.getUint32(),i=s===20480?"0.5":s===65536?"1.0":null;y(i,`Unsupported maxp table version (expected 0x00005000 or 0x00010000 but found ${s.toString(16)}).`);const o=e.getUint16(),c={version:i,numGlyphs:o};return e.setPosition(n),c}function At(e,t){const n=e.getPosition();e.setPosition(t);const s=e.getUint16(),i=e.getUint16(),o=e.getInt16(),c=e.getInt16(),a=e.getInt16(),p=e.getUint16(),r=e.getInt16(),h=e.getInt16(),l=e.getInt16(),m=e.getInt16(),u=e.getInt16(),b=e.getInt16(),g=e.getInt16(),U=e.getInt16(),P=e.getInt16(),f=e.getInt16(),x=e.getInt16(),w=e.getUint16(),I={majorVersion:s,minorVersion:i,ascender:o,descender:c,lineGap:a,advanceWidthMax:p,minLeftSideBearing:r,minRightSideBearing:h,xMaxExtent:l,caretSlopeRise:m,caretSlopeRun:u,caretOffset:b,reserved1:g,reserved2:U,reserved3:P,reserved4:f,metricDataFormat:x,numberOfHMetrics:w};return e.setPosition(n),I}function Dt(e,t,n,s){const i=e.getPosition();e.setPosition(t);const o=[];for(let p=0;p<s;p++)o.push({advanceWidth:e.getUint16(),leftSideBearing:e.getInt16()});const c=[];for(let p=0;p<n-s;p++)c.push(e.getInt16());const a={hMetrics:o,leftSideBearings:c};return y(o.length+c.length===n,`The number of hMetrics (${o.length}) plus the number of left side bearings (${c.length}) must equal the number of glyphs (${n}).`),e.setPosition(i),a}function Gt(e,t,n,s){const i=e.getPosition();e.setPosition(t);const o=[];for(let c=0;c<n+1;c++)o.push(s===0?e.getUint16():e.getUint32());return e.setPosition(i),{offsets:o}}function Et(e,t,n,s){const i=e.getPosition();e.setPosition(t);const o=[];for(let c=0;c<n.offsets.length-1;c++){const a=s===0?2:1,p=n.offsets[c]*a;e.setPosition(t+p),o.push({numberOfContours:e.getInt16(),xMin:e.getInt16(),yMin:e.getInt16(),xMax:e.getInt16(),yMax:e.getInt16()})}return e.setPosition(i),o}function Ot(e,t,n){const s=e.getPosition();e.setPosition(t);const i=e.getUint16(),o=e.getUint16();y(i===1&&o===0,"Only GPOS version 1.0 is supported."),e.getUint16();const c=e.getUint16(),a=e.getUint16();e.setPosition(t+c);const p=e.getUint16(),r=[],h=[];for(let g=0;g<p;g++){const U=e.getString(4),P=e.getUint16(),f={tag:U,offset:P};r.push(f)}for(let g=0;g<p;g++){e.setPosition(t+c+r[g].offset);const U=e.getUint16(),P=e.getUint16(),f=[];for(let x=0;x<P;x++)f.push(e.getUint16());h.push({tag:r[g].tag,paramsOffset:U,lookupListIndices:f})}e.setPosition(t+a);const l=e.getUint16();let m;(g=>{g[g.SingleAdjustment=1]="SingleAdjustment",g[g.PairAdjustment=2]="PairAdjustment",g[g.CursiveAttachment=3]="CursiveAttachment",g[g.MarkToBaseAttachment=4]="MarkToBaseAttachment",g[g.MarkToLigatureAttachment=5]="MarkToLigatureAttachment",g[g.MarkToMarkAttachment=6]="MarkToMarkAttachment",g[g.ContextPositioning=7]="ContextPositioning",g[g.ChainedContextPositioning=8]="ChainedContextPositioning",g[g.ExtensionPositioning=9]="ExtensionPositioning"})(m||(m={}));const u=[];for(let g=0;g<l;g++)u.push(e.getUint16());const b=[];for(let g=0;g<l;g++){e.setPosition(t+a+u[g]);const U=e.getUint16(),P=e.getUint16(),f=e.getUint16(),x=[];for(let d=0;d<f;d++)x.push(e.getUint16());let w;P&16&&(w=e.getUint16());const I={lookupType:U,lookupFlag:P,subtables:[],markFilteringSet:w};if(U===9)for(let d=0;d<f;d++){e.setPosition(t+a+u[g]+x[d]);const C=e.getUint16(),M=e.getUint16(),S=e.getUint32();let T={};e.runAt(t+a+u[g]+x[d]+S,()=>{if(M===2){const F=e.getUint16();if(y(F===1||F===2,"Invalid posFormat."),T.posFormat=F,F===1){const A=e.getUint16(),O=e.getUint16(),z=e.getUint16(),R=e.getUint16(),W=[];for(let D=0;D<R;D++)W.push(e.getUint16());const k=[];for(let D=0;D<R;D++){e.setPosition(t+a+u[g]+x[d]+S+W[D]);const H=e.getUint16(),q=[];for(let V=0;V<H;V++){const E={secondGlyph:e.getUint16()},N=_(e,O),L=_(e,z);N&&(E.value1=N),L&&(E.value2=L),q.push(E)}k.push(q)}T.coverage=e.runAt(t+a+u[g]+x[d]+S+A,()=>{const D=e.getUint16();return st(e,D)}),T={...T,valueFormat1:O,valueFormat2:z,pairSets:k}}else if(F===2){const A=e.getUint16(),O=e.getUint16(),z=e.getUint16(),R=e.getUint16(),W=e.getUint16(),k=e.getUint16(),D=e.getUint16();T.coverage=e.runAt(t+a+u[g]+x[d]+S+A,()=>{const E=e.getUint16();return st(e,E)});let H=e.runAt(t+a+u[g]+x[d]+S+R,()=>it(e)),q=e.runAt(t+a+u[g]+x[d]+S+W,()=>it(e));const V=[];for(let E=0;E<k;E++){let N=[];for(let L=0;L<D;L++){const Y={},Q=_(e,O),tt=_(e,z);Q&&(Y.value1=Q),tt&&(Y.value2=tt),N.push(Y)}V.push(N)}T={...T,valueFormat1:O,valueFormat2:z,classDef1:H,classDef2:q,classRecords:V}}else n&&console.warn("Only Pair Adjustment lookup format 1 and 2 are supported.")}}),I.subtables.push({posFormat:C,extensionLookupType:M,extension:T})}else n&&console.warn("Only Extension Positioning lookup type is supported.");b.push(I)}return e.setPosition(s),{features:h,lookups:b}}function _(e,t){let n={};if(t&1&&(n.xPlacement=e.getInt16()),t&2&&(n.yPlacement=e.getInt16()),t&4&&(n.xAdvance=e.getInt16()),t&8&&(n.yAdvance=e.getInt16()),t&16&&(n.xPlaDevice=e.getInt16()),t&32&&(n.yPlaDevice=e.getInt16()),t&64&&(n.xAdvDevice=e.getInt16()),t&128&&(n.yAdvDevice=e.getInt16()),Object.keys(n).length!==0)return n}function st(e,t){if(t===2){const n=e.getUint16(),s=[];for(let i=0;i<n;i++)s.push({startGlyphID:e.getUint16(),endGlyphID:e.getUint16(),startCoverageIndex:e.getUint16()});return{coverageFormat:t,rangeRecords:s}}else throw new Error("Only Coverage Table format 2 is supported as of now.")}function it(e){const t=e.getUint16();if(t===1){const n=e.getUint16(),s=e.getUint16(),i=[];for(let o=0;o<s;o++)i.push(e.getUint16());return{format:t,startGlyph:n,classes:i}}else if(t===2){const n=e.getUint16(),s=[];for(let i=0;i<n;i++)s.push({startGlyphID:e.getUint16(),endGlyphID:e.getUint16(),class:e.getUint16()});return{format:t,ranges:s}}else throw new Error(`Unsupported ClassDef format ${t}.`)}const zt=.001;class B{constructor(t,n,s,i){this.x=t,this.y=n,this.z=s,this.w=i}add(t){return new B(this.x+t.x,this.y+t.y,this.z+t.z,this.w+t.w)}subtract(t){return new B(this.x-t.x,this.y-t.y,this.z-t.z,this.w-t.w)}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}normalize(){const t=this.length();return new B(this.x/t,this.y/t,this.z/t,this.w/t)}scale(t){return new B(this.x*t,this.y*t,this.z*t,this.w*t)}cross(t){return new B(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x,0)}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}distance(t){return this.subtract(t).length()}lerp(t,n){return this.add(t.subtract(this).scale(n))}equalsEpsilon(t,n){return Math.abs(this.x-t.x)<n&&Math.abs(this.y-t.y)<n&&Math.abs(this.z-t.z)<n&&Math.abs(this.w-t.w)<n}equals(t){return this.equalsEpsilon(t,zt)}}function Bt(e){let t=0,n=0;const s=e.map((r,h)=>({id:h,x:0,y:0,width:r.x,height:r.y}));for(const r of s)t+=r.width*r.height,n=Math.max(n,r.width);s.sort((r,h)=>h.height-r.height);const o=[{x:0,y:0,width:Math.max(Math.ceil(Math.sqrt(t/.95)),n),height:1/0}];let c=0,a=0;for(const r of s)for(let h=o.length-1;h>=0;h--){const l=o[h];if(!(r.width>l.width||r.height>l.height)){if(r.x=l.x,r.y=l.y,a=Math.max(a,r.y+r.height),c=Math.max(c,r.x+r.width),r.width===l.width&&r.height===l.height){const m=o.pop();y(m,"Regions array should not be empty."),h<o.length&&(o[h]=m)}else r.height===l.height?(l.x+=r.width,l.width-=r.width):r.width===l.width?(l.y+=r.height,l.height-=r.height):(o.push({x:l.x+r.width,y:l.y,width:l.width-r.width,height:r.height}),l.y+=r.height,l.height-=r.height);break}}const p=Math.max(ot(c),ot(a));return s.sort((r,h)=>r.id-h.id),{width:p,height:p,positions:s.map(r=>new G(r.x,r.y))}}function ot(e){let t=e;return t-=1,t|=t>>1,t|=t>>2,t|=t>>4,t|=t>>8,t|=t>>16,t+=1,t}function Rt(e,t){return(t?t.split("").map(s=>s.charCodeAt(0)):[...e.cmap.glyphIndexMap.keys()]).map(s=>{y(e,"TTF is missing.");const i=e.cmap.glyphIndexMap.get(s);y(i,`Couldn't find index for character '${String.fromCharCode(s)}' in glyphIndexMap.`),y(i<e.glyf.length,"Index is out of bounds for glyf table.");const o=e.hmtx.hMetrics.at(-1);y(o,"The last advance is missing, which means that hmtx table is probably empty.");const c=i<e.hhea.numberOfHMetrics?e.hmtx.hMetrics[i]:{leftSideBearing:e.hmtx.leftSideBearings[i-e.hhea.numberOfHMetrics],advanceWidth:o.advanceWidth},a=e.glyf[i];return{id:s,character:String.fromCharCode(s),x:a.xMin,y:a.yMin,width:a.xMax-a.xMin,height:a.yMax-a.yMin,lsb:c.leftSideBearing,rsb:c.advanceWidth-c.leftSideBearing-(a.xMax-a.xMin)}})}function Vt(e,t){var U,P;const n=1/e.head.unitsPerEm*j,s=Rt(e,t==null?void 0:t.alphabet),i=f=>Math.ceil(f*n),o=s.map(f=>new G(i(f.width)+$*2,i(f.height)+$*2)),c=Bt(o);y(c.positions.length===s.length,"Packing produced different number of positions than expected.");const a={width:c.width,height:c.height,positions:c.positions,sizes:o},p=[];for(let f=0;f<s.length;f++){const x=a.positions[f],w=a.sizes[f];p.push(new B(x.x/a.width,x.y/a.height,w.x/a.width,w.y/a.height))}const r=new Map;for(const f of s)r.set(f.id,f);const h=new Map;for(let f=0;f<s.length;f++)h.set(s[f].id,p[f]);const l=new Map;let m=new Map,u=new Map,b=[];const g=(U=e.GPOS)==null?void 0:U.features.find(f=>f.tag==="kern");if(g){const f=g.lookupListIndices.map(x=>{var w;return(w=e.GPOS)==null?void 0:w.lookups[x]});for(const x of f)if(x&&(x.lookupType===2||x.lookupType===9)){for(const w of x.subtables)if(x.lookupType===9&&w.extensionLookupType===2){const I=w.extension.coverage;if(w.extension.posFormat===1){const d=w.extension.pairSets;if(I.coverageFormat===2){let C=0;for(const M of I.rangeRecords)for(let S=M.startGlyphID;S<=M.endGlyphID;S++){const T=d[C],F=l.get(S)||new Map;for(const A of T)(P=A.value1)!=null&&P.xAdvance&&F.set(A.secondGlyph,A.value1.xAdvance);F.size>0&&l.set(S,F),C++}}else console.warn(`Coverage format ${I.coverageFormat} is not supported.`)}else if(w.extension.posFormat===2)if(I.coverageFormat===2){const{classDef1:d,classDef2:C}=w.extension;m=at(d),u=at(C),b=w.extension.classRecords}else console.warn(`Coverage format ${I.coverageFormat} is not supported.`)}}}return{atlas:a,unitsPerEm:e.head.unitsPerEm,capHeight:e.hhea.ascender+e.hhea.descender,ascender:e.hhea.ascender,glyphs:r,uvs:h,kern:(f,x)=>{var S;if(!e.GPOS)return 0;const w=e.cmap.glyphIndexMap.get(f),I=e.cmap.glyphIndexMap.get(x);y(w,`Glyph not found for: "${f}"`),y(I,`Glyph not found for: "${x}"`);const d=l.get(w);if(d&&d.get(I))return d.get(I)??0;const C=m.get(w),M=u.get(I);return C&&M?((S=b[C][M].value1)==null?void 0:S.xAdvance)??0:0},ttf:e}}function at(e){const t=new Map;if(e.format===1){let n=e.startGlyph;for(const s of e.classes)t.set(n,s),n++}else if(e.format===2)for(const n of e.ranges)for(let s=n.startGlyphID;s<=n.endGlyphID;s++)t.set(s,n.class);return t}const Nt=4;let Z,ct,rt,J;async function Lt(e,t){const{fontSource:n,device:s,canvas:i,context:o}=e,{debug:c}=t,p=s.createTexture({label:"colorTexture",size:{width:i.width,height:i.height},sampleCount:Nt,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}).createView({label:"color"}),r=new Ut({device:s,context:o,colorTextureView:p,width:i.width,height:i.height,clearValue:t.clearValue,fontColorValue:t.fontColorValue});y(n,"'fontSource' must be set."),Z||(Z=await fetch(n).then(l=>l.arrayBuffer())),ct||(ct=Mt(Z,{debug:c})),J||(J=Vt(ct)),rt||(rt=await mt(J,Z,{useSDF:!0}));const h=await Pt(s,rt);return r.setFont(J,h),r}class $t{constructor(t,n){v(this,"device");v(this,"context");v(this,"canvas");v(this,"settings");this.canvas=t,this.settings=n,this.debug("initialized")}log(...t){var n;(n=this.settings)!=null&&n.log&&console.log("WebGPUEngine:",...t)}debug(...t){var n;(n=this.settings)!=null&&n.debug&&console.debug("WebGPUEngine:",...t)}error(...t){console.error("WebGPUEngine:",...t)}async initialize(t){try{const n=await navigator.gpu.requestAdapter({powerPreference:"low-power"});if(!n){this.error("WebGPU adapter is not available.");return}const s=await n.requestDevice({requiredLimits:{maxStorageBufferBindingSize:n.limits.maxStorageBufferBindingSize}});this.device=s,s.lost.then(async o=>{this.error(`WebGPU device was lost: ${o.message}`),o.reason!=="destroyed"&&(await this.initialize(t),this.log("WebGPU device was re-initialized."))});const i=t.getContext("webgpu");if(!i)return;if(this.context=i,!i){this.error("WebGPU context is not available.");return}i.configure({device:s,format:navigator.gpu.getPreferredCanvasFormat()})}catch(n){this.error("Error initializing WebGPU: ",n)}}observeSizeChanges(t,n){var s;new pt(t,(s=this.settings)==null?void 0:s.debounceInterval,async(i,o)=>{t.width=i*window.devicePixelRatio,t.height=o*window.devicePixelRatio,this.debug("New width:",i,", new height:",o),await(n==null?void 0:n(i,o)),t.style.width=`${i}px`,t.style.height=`${o}px`})}render(t){this.observeSizeChanges(this.canvas,async(n,s)=>{var o;this.log("Observing canvas size changes"),await this.initialize(this.canvas);const i=await this.loadFont({fontSource:(o=this.settings)==null?void 0:o.fontSource,device:this.device,canvas:this.canvas,context:this.context},{debug:this.settings.debug??!1,clearValue:this.settings.clearValue,fontColorValue:this.settings.fontColorValue,width:n,height:s});y(t,"No post-render function provided"),t({device:this.device,context:this.context,font:i,width:n,height:s})})}loadFont(t,n){return Lt({...t},{...n})}}class kt{constructor(t,n){v(this,"engine");v(this,"settings");const s=document.createElement("canvas");if(!t)throw new Error("No element provided");t.appendChild(s),t.style.overflow="hidden",t.style.width="100%",t.style.height="100%",this.settings=n??ft,this.log("initialize"),this.engine=new $t(s,this.settings)}log(...t){var n;(n=this.settings)!=null&&n.log&&console.log("Chart:",...t)}error(...t){console.error("Chart:",...t)}async render(t){if(!t){this.error("No render function provided");return}this.engine.render(async({device:n,context:s,width:i,height:o,font:c})=>{t({device:n,context:s,width:i,height:o,font:c})})}}export{kt as C,G as V,B as a,ut as b,ft as c};
